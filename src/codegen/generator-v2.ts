/**
 * Cap'n Proto TypeScript 代码生成器 v2
 */

import type { Schema, Struct, Enum, Field, Type } from './parser-v2.js';

export interface GeneratorOptions {
  runtimeImportPath?: string;
}

const DEFAULT_OPTIONS: GeneratorOptions = {
  runtimeImportPath: '@naeemo/capnp',
};

export function generateCode(schema: Schema, options?: GeneratorOptions): string {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const lines: string[] = [];
  
  // 文件头
  lines.push('// Generated by capnp-ts-codegen');
  lines.push('// DO NOT EDIT MANUALLY');
  lines.push('');
  lines.push(\`import { MessageReader, MessageBuilder, StructReader, StructBuilder } from '\${opts.runtimeImportPath}';\`);
  lines.push('');
  
  // 生成枚举
  for (const enum_ of schema.enums) {
    lines.push(\`export enum \${enum_.name} {\`);
    for (const value of enum_.values) {
      lines.push(\`  \${value.name} = \${value.index},\`);
    }
    lines.push('}');
    lines.push('');
  }
  
  // 生成结构体
  for (const struct of schema.structs) {
    generateStruct(struct, lines);
  }
  
  return lines.join('\n');
}

function generateStruct(struct: Struct, lines: string[]): void {
  // 计算布局
  let dataWords = 0;
  let pointerCount = 0;
  let dataOffset = 0;
  
  for (const field of struct.fields) {
    if (isPointerType(field.type)) {
      pointerCount++;
    } else {
      dataOffset += getTypeSize(field.type);
    }
  }
  dataWords = Math.ceil(dataOffset / 8);
  
  // 生成接口
  lines.push(\`export interface \${struct.name} {\`);
  for (const field of struct.fields) {
    lines.push(\`  \${field.name}: \${mapTypeToTs(field.type)};\`);
  }
  lines.push('}');
  lines.push('');
  
  // 生成 Reader
  lines.push(\`export class \${struct.name}Reader {\`);
  lines.push('  private reader: StructReader;');
  lines.push('');
  lines.push('  constructor(reader: StructReader) {');
  lines.push('    this.reader = reader;');
  lines.push('  }');
  lines.push('');
  
  dataOffset = 0;
  let pointerIndex = 0;
  for (const field of struct.fields) {
    const tsType = mapTypeToTs(field.type);
    if (isPointerType(field.type)) {
      const method = getGetterMethod(field.type);
      lines.push(\`  get \${field.name}(): \${tsType} {\`);
      lines.push(\`    return this.reader.\${method}(\${pointerIndex});\`);
      lines.push('  }');
      pointerIndex++;
    } else {
      const method = getGetterMethod(field.type);
      lines.push(\`  get \${field.name}(): \${tsType} {\`);
      lines.push(\`    return this.reader.\${method}(\${dataOffset});\`);
      lines.push('  }');
      dataOffset += getTypeSize(field.type);
    }
    lines.push('');
  }
  lines.push('}');
  lines.push('');
  
  // 生成 Builder
  lines.push(\`export class \${struct.name}Builder {\`);
  lines.push('  private builder: StructBuilder;');
  lines.push('');
  lines.push('  constructor(builder: StructBuilder) {');
  lines.push('    this.builder = builder;');
  lines.push('  }');
  lines.push('');
  lines.push(\`  static create(message: MessageBuilder): \${struct.name}Builder {\`);
  lines.push(\`    const root = message.initRoot(\${dataWords}, \${pointerCount});\`);
  lines.push(\`    return new \${struct.name}Builder(root);\`);
  lines.push('  }');
  lines.push('');
  
  dataOffset = 0;
  pointerIndex = 0;
  for (const field of struct.fields) {
    const tsType = mapTypeToTs(field.type);
    const method = getSetterMethod(field.type);
    if (isPointerType(field.type)) {
      lines.push(\`  set\${capitalize(field.name)}(value: \${tsType}): void {\`);
      lines.push(\`    this.builder.\${method}(\${pointerIndex}, value);\`);
      lines.push('  }');
      pointerIndex++;
    } else {
      lines.push(\`  set\${capitalize(field.name)}(value: \${tsType}): void {\`);
      lines.push(\`    this.builder.\${method}(\${dataOffset}, value);\`);
      lines.push('  }');
      dataOffset += getTypeSize(field.type);
    }
    lines.push('');
  }
  lines.push('}');
  lines.push('');
}

function isPointerType(type: Type): boolean {
  if (typeof type === 'string') {
    return type === 'Text' || type === 'Data';
  }
  return type.kind === 'list' || type.kind === 'struct';
}

function getTypeSize(type: Type): number {
  if (typeof type !== 'string') return 8;
  switch (type) {
    case 'Void': return 0;
    case 'Bool': return 1;
    case 'Int8': case 'UInt8': return 1;
    case 'Int16': case 'UInt16': return 2;
    case 'Int32': case 'UInt32': case 'Float32': return 4;
    case 'Int64': case 'UInt64': case 'Float64': return 8;
    default: return 8;
  }
}

function mapTypeToTs(type: Type): string {
  if (typeof type !== 'string') {
    if (type.kind === 'list') return \`\${mapTypeToTs(type.elementType)}[]\`;
    return type.name;
  }
  switch (type) {
    case 'Void': return 'void';
    case 'Bool': return 'boolean';
    case 'Int8': case 'Int16': case 'Int32':
    case 'UInt8': case 'UInt16': case 'UInt32':
    case 'Float32': case 'Float64': return 'number';
    case 'Int64': case 'UInt64': return 'bigint';
    case 'Text': return 'string';
    case 'Data': return 'Uint8Array';
    default: return 'unknown';
  }
}

function getGetterMethod(type: Type): string {
  if (typeof type !== 'string') {
    if (type.kind === 'list') return 'getList';
    return 'getStruct';
  }
  switch (type) {
    case 'Void': return 'getVoid';
    case 'Bool': return 'getBool';
    case 'Int8': return 'getInt8';
    case 'Int16': return 'getInt16';
    case 'Int32': return 'getInt32';
    case 'Int64': return 'getInt64';
    case 'UInt8': return 'getUint8';
    case 'UInt16': return 'getUint16';
    case 'UInt32': return 'getUint32';
    case 'UInt64': return 'getUint64';
    case 'Float32': return 'getFloat32';
    case 'Float64': return 'getFloat64';
    case 'Text': return 'getText';
    case 'Data': return 'getData';
    default: return 'getUnknown';
  }
}

function getSetterMethod(type: Type): string {
  if (typeof type !== 'string') {
    if (type.kind === 'list') return 'initList';
    return 'initStruct';
  }
  switch (type) {
    case 'Void': return 'setVoid';
    case 'Bool': return 'setBool';
    case 'Int8': return 'setInt8';
    case 'Int16': return 'setInt16';
    case 'Int32': return 'setInt32';
    case 'Int64': return 'setInt64';
    case 'UInt8': return 'setUint8';
    case 'UInt16': return 'setUint16';
    case 'UInt32': return 'setUint32';
    case 'UInt64': return 'setUint64';
    case 'Float32': return 'setFloat32';
    case 'Float64': return 'setFloat64';
    case 'Text': return 'setText';
    case 'Data': return 'setData';
    default: return 'setUnknown';
  }
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

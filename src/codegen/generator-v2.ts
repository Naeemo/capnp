/**
 * Cap'n Proto TypeScript 代码生成器 v2
 * 生成完整的 TypeScript 代码
 */

import type {
  SchemaFile,
  StructDeclaration,
  EnumDeclaration,
  Field,
  Type,
  Union,
} from './parser-v2.js';
import type { StructLayout, LayoutField } from './layout.js';
import { computeStructLayout } from './layout.js';

export interface GeneratorOptions {
  runtimeImportPath?: string;
}

const DEFAULT_OPTIONS: GeneratorOptions = {
  runtimeImportPath: '@naeemo/capnp',
};

class CodeGenerator {
  private options: GeneratorOptions;
  private lines: string[] = [];
  private indentLevel = 0;

  constructor(options: GeneratorOptions = {}) {
    this.options = { ...DEFAULT_OPTIONS, ...options };
  }

  generate(schema: SchemaFile): string {
    this.lines = [];
    this.indentLevel = 0;

    // 文件头
    this.line('// Generated by capnp-ts-codegen');
    this.line('// DO NOT EDIT MANUALLY');
    this.line('');

    // 导入
    const runtime = this.options.runtimeImportPath!;
    this.line(`import { MessageReader, MessageBuilder, StructReader, StructBuilder } from '${runtime}';`);
    this.line('');

    // 生成枚举
    for (const decl of schema.declarations) {
      if (decl.kind === 'enum') {
        this.generateEnum(decl);
      }
    }

    // 生成结构体
    for (const decl of schema.declarations) {
      if (decl.kind === 'struct') {
        this.generateStruct(decl);
      }
    }

    return this.lines.join('\n');
  }

  private generateEnum(enumDecl: EnumDeclaration): void {
    this.line(`export enum ${enumDecl.name} {`);
    this.indent();
    for (const value of enumDecl.values) {
      this.line(`${value.name} = ${value.index},`);
    }
    this.dedent();
    this.line('}');
    this.line('');
  }

  private generateStruct(structDecl: StructDeclaration): void {
    const layout = computeStructLayout(structDecl);

    // 生成 TypeScript 接口
    this.generateInterface(structDecl, layout);

    // 生成 Reader 类
    this.generateReader(structDecl, layout);

    // 生成 Builder 类
    this.generateBuilder(structDecl, layout);
  }

  private generateInterface(structDecl: StructDeclaration, layout: StructLayout): void {
    this.line(`export interface ${structDecl.name} {`);
    this.indent();

    // 普通字段
    for (const field of structDecl.fields) {
      const tsType = this.mapTypeToTs(field.type);
      const optional = field.type.kind === 'optional' ? '?' : '';
      this.line(`${field.name}${optional}: ${tsType};`);
    }

    // Union 字段
    for (const union of structDecl.unions) {
      if (union.name) {
        this.line(`${union.name}: ${this.generateUnionType(union)};`);
      }
    }

    this.dedent();
    this.line('}');
    this.line('');
  }

  private generateUnionType(union: Union): string {
    const variants = union.fields.map(f => {
      const tsType = this.mapTypeToTs(f.type);
      return `{ ${f.name}: ${tsType} }`;
    });
    return variants.join(' | ');
  }

  private generateReader(structDecl: StructDeclaration, layout: StructLayout): void {
    this.line(`export class ${structDecl.name}Reader extends StructReader {`);
    this.indent();

    // 构造函数
    this.line(`constructor(reader: StructReader) {`);
    this.indent();
    this.line('super(reader);');
    this.dedent();
    this.line('}');
    this.line('');

    // Getter 方法
    for (const field of layout.fields) {
      this.generateFieldGetter(field);
    }

    this.dedent();
    this.line('}');
    this.line('');
  }

  private generateBuilder(structDecl: StructDeclaration, layout: StructLayout): void {
    this.line(`export class ${structDecl.name}Builder extends StructBuilder {`);
    this.indent();

    // 静态方法：创建新 builder
    this.line(`static create(message: MessageBuilder): ${structDecl.name}Builder {`);
    this.indent();
    this.line(`const root = message.initRoot(${layout.dataWords}, ${layout.pointerCount});`);
    this.line(`return new ${structDecl.name}Builder(root);`);
    this.dedent();
    this.line('}');
    this.line('');

    // 构造函数
    this.line(`constructor(builder: StructBuilder) {`);
    this.indent();
    this.line('super(builder);');
    this.dedent();
    this.line('}');
    this.line('');

    // Setter 方法
    for (const field of layout.fields) {
      this.generateFieldSetter(field);
    }

    this.dedent();
    this.line('}');
    this.line('');
  }

  private generateFieldGetter(field: LayoutField): void {
    const tsType = this.mapTypeToTs(field.type);
    const method = this.getGetterMethod(field.type);

    if (field.pointerIndex !== undefined) {
      // 指针类型
      this.line(`get ${field.name}(): ${tsType} {`);
      this.indent();
      this.line(`return this.${method}(${field.pointerIndex});`);
      this.dedent();
      this.line('}');
    } else if (field.bitOffset !== undefined) {
      // Bool 类型（位偏移）
      const bitIndex = field.byteOffset * 8 + field.bitOffset;
      this.line(`get ${field.name}(): ${tsType} {`);
      this.indent();
      this.line(`return this.${method}(${bitIndex});`);
      this.dedent();
      this.line('}');
    } else {
      // 普通数据类型
      this.line(`get ${field.name}(): ${tsType} {`);
      this.indent();
      this.line(`return this.${method}(${field.byteOffset});`);
      this.dedent();
      this.line('}');
    }
    this.line('');
  }

  private generateFieldSetter(field: LayoutField): void {
    const tsType = this.mapTypeToTs(field.type);
    const method = this.getSetterMethod(field.type);

    if (field.pointerIndex !== undefined) {
      // 指针类型
      this.line(`set${this.capitalize(field.name)}(value: ${tsType}): void {`);
      this.indent();
      this.line(`this.${method}(${field.pointerIndex}, value);`);
      this.dedent();
      this.line('}');
    } else if (field.bitOffset !== undefined) {
      // Bool 类型
      const bitIndex = field.byteOffset * 8 + field.bitOffset;
      this.line(`set${this.capitalize(field.name)}(value: ${tsType}): void {`);
      this.indent();
      this.line(`this.${method}(${bitIndex}, value);`);
      this.dedent();
      this.line('}');
    } else {
      // 普通数据类型
      this.line(`set${this.capitalize(field.name)}(value: ${tsType}): void {`);
      this.indent();
      this.line(`this.${method}(${field.byteOffset}, value);`);
      this.dedent();
      this.line('}');
    }
    this.line('');
  }

  private mapTypeToTs(type: Type): string {
    switch (type.kind) {
      case 'void': return 'void';
      case 'bool': return 'boolean';
      case 'int8':
      case 'int16':
      case 'int32':
      case 'uint8':
      case 'uint16':
      case 'uint32':
      case 'float32':
      case 'float64': return 'number';
      case 'int64':
      case 'uint64': return 'bigint';
      case 'text': return 'string';
      case 'data': return 'Uint8Array';
      case 'list': return `${this.mapTypeToTs(type.elementType)}[]`;
      case 'struct': return type.name;
      case 'enum': return type.name;
      case 'anyPointer': return 'unknown';
      case 'capability': return 'unknown';
      case 'optional': return `${this.mapTypeToTs(type.inner)} | undefined`;
      default: return 'unknown';
    }
  }

  private getGetterMethod(type: Type): string {
    switch (type.kind) {
      case 'void': return 'getVoid';
      case 'bool': return 'getBool';
      case 'int8': return 'getInt8';
      case 'int16': return 'getInt16';
      case 'int32': return 'getInt32';
      case 'int64': return 'getInt64';
      case 'uint8': return 'getUint8';
      case 'uint16': return 'getUint16';
      case 'uint32': return 'getUint32';
      case 'uint64': return 'getUint64';
      case 'float32': return 'getFloat32';
      case 'float64': return 'getFloat64';
      case 'text': return 'getText';
      case 'data': return 'getData';
      case 'list': return 'getList';
      case 'struct': return 'getStruct';
      case 'enum': return 'getUint16';
      case 'anyPointer': return 'getAnyPointer';
      case 'capability': return 'getCapability';
      case 'optional': return this.getGetterMethod(type.inner);
      default: return 'getUnknown';
    }
  }

  private getSetterMethod(type: Type): string {
    switch (type.kind) {
      case 'void': return 'setVoid';
      case 'bool': return 'setBool';
      case 'int8': return 'setInt8';
      case 'int16': return 'setInt16';
      case 'int32': return 'setInt32';
      case 'int64': return 'setInt64';
      case 'uint8': return 'setUint8';
      case 'uint16': return 'setUint16';
      case 'uint32': return 'setUint32';
      case 'uint64': return 'setUint64';
      case 'float32': return 'setFloat32';
      case 'float64': return 'setFloat64';
      case 'text': return 'setText';
      case 'data': return 'setData';
      case 'list': return 'initList';
      case 'struct': return 'initStruct';
      case 'enum': return 'setUint16';
      case 'anyPointer': return 'setAnyPointer';
      case 'capability': return 'setCapability';
      case 'optional': return this.getSetterMethod(type.inner);
      default: return 'setUnknown';
    }
  }

  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  private line(text: string): void {
    this.lines.push('  '.repeat(this.indentLevel) + text);
  }

  private indent(): void {
    this.indentLevel++;
  }

  private dedent(): void {
    this.indentLevel--;
  }
}

export function generateCode(schema: SchemaFile, options?: GeneratorOptions): string {
  const generator = new CodeGenerator(options);
  return generator.generate(schema);
}
